#                                    数据结构与算法

![image-20240622020223772](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622020223772.png)

在数据结构中，从**逻辑**上可以把数据结构分成**线性结构和非线性结构**。

数据的**基本单位**是数据元素，数据的**最小单位**是数据项。

**数据对象**：是性质相同的数据元素的集合，是数据的子集

**数据结构是数据对象，以及存在于该对象的实例合组成实例的数据元素之间的各种联系**。这些联系可以通过定义相关的函数来给出。



**递归算法**：必须包括终止条件和递归部分

**回溯算法**：核心思想是:从根结点出发,沿着某条路径向前搜索,当搜索到某一结点发现不满足要求时,就返回(回溯)到上一结点,继续尝试其他路径。回溯算法不需要使用队列来保存路径,而是通过递归调用、返回上一层等方式来实现状态的保存和恢复。





### 存储结构：

描述了数据在计算机内部的实际存储方式。它主要关注数据在计算机内存中的组织形式，以及如何在内存中存储和访问数据。存储结构通常包括以下几种：

**顺序存储结构**：数据元素在内存中按照一定的顺序依次存储，相邻的元素**在内存中也是相邻的**，如**顺序表、数组**，可以**随机存取**。

**链式存储结构**：数据元素通过指针相互连接，每个元素在内存中可以不连续存储（可能连续也可能不连续），如链表。链接存储的存储结构所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针（单链表数据密度<1）

**索引存储结构**：除了数据元素本身外，还维护一个索引表，索引表中的每个元素指向相应数据元素的位置。

**散列存储结构**：通过散列函数将数据元素直接映射到内存地址，实现快速的查找。

存储结构与具体的数据结构有关，不同的数据结构可以选择不同的存储结构来实现。例如，数组通常使用顺序存储结构，链表则使用链式存储结构。

 

### 逻辑结构：

描述了数据元素之间的逻辑关系，以及对这些关系的操作。它不涉及具体的存储细节，而是关注数据元素之间的关联和组织方式。通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致 

**线性结构**：数据元素之间存在一对一的关系，可以通过一维的方式排列，例如线性表、栈、队列等。

**树形结构**：数据元素之间存在一对多的关系，可以用树形方式组织，例如二叉树、堆、哈夫曼树等。

**图形结构**：数据元素之间存在多对多的关系，例如图、网等。

（有序表也属于逻辑结构） 

逻辑结构与数据的抽象关系更为密切，它们描述了数据元素之间的逻辑联系和操作规则，而***\*不关注数据元素的存储方式\****。例如，队列的逻辑结构就是先进先出（FIFO）的关系，而队列的存储方式可以是数组或链表。

###  常见数据结构：

**单链表**：是*\*一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素\**。链表中的数据是以*\*结点\**来表示的，每个*\*结点\**的构成：*\*元素(数据元素的映象) + 指针(指示后继元素存储位置)\**，*\*元素\**就是存储数据的存储单元，*\*指针\**就是连接每个结点的地址数据。

**串**：是一种特殊的线性表，其元素为一个字符

**线性表**：其中元素属于同一数据类型，所占大小必须相同。



![image-20240622020930375](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622020930375.png)

## 一.排序（建议搜网上动图理解）:

##### 排序：是计算机程序设计中的一种重要操作，其功能是对一个数据元素集合或序列重新排列成一个按数据元素某个值有序的序列。

![image-20240622020005424](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622020005424.png)

（上图快排空间复杂度为lgn)

**归并排序：每一趟是指对每2.4.8.···个进行归并**

**希尔排序：一趟是针对步长而言（步长是指元素索引差值）**



### （1）快排：

##### 霍尔法：![image-20240622021102637](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622021102637.png)

#### ①最好情况： 

时间复杂度为：O(nlogn)：即每次划分产生的两个区间大小都为区间总长（设为n）的一半； 

空间复杂度：o（lgn），也是一般情况（上面标错了）

####  ②最坏情况： 

时间复杂度为：O(n^2) ，即每次划分产生的两个区间大小分别包含n-1个元素和1个元素； 

空间复杂度为：O(n) 

（注：快排使用的空间为：O（1），真正消耗空间的是递归调用。）

![image-20240622021150829](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622021150829.png) 

### （2）堆排序

#### 基本步骤：

1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端

2.将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1

3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组



**堆排序是选择排序，堆是完全二叉树，堆排序最适用于partial-sort.**



### （3）归并排序

![image-20240622021327602](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622021327602.png)

![image-20240622021605167](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622021605167.png)

# 二.散列表



**散列函数和散列地址：**在记录的存储位置p和其关键字key之间建立一个确定的对应关系H，使得p=H(key)，称这个对应关系H为散列函数，p为散列地址

**散列表**：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

**冲突和同义词**：对不同的关键字可能得到同一散列地址，即key1 != key2，但是H(key1) == H(key2)，这种现象称为冲突。具有相同函数值的关键字对该散列表函数来说称为同义词，key1与key2互称为同义词。

（eg：A称为关键字key，则A经过关系H后，在数组中的位置称为存储位置p；而不同的关键字8，4，经过关系（关键字%2）得到的存储地址都是0，称为冲突，而8，4则为同义词）

### 1.开放地址法

开放地址法的基本思想是：把记录都存储在散列表数组中，当某一记录关键字 key 的初始散列地址 H0 = H(key)发生冲突时，以 H0 为基础，采取合适方法计算得到另一个地址 H1，如果 H1 仍然发生冲突，以 为基础再求下一个地址 H2，若 H2 仍然冲突，再求得 H3。依次类推，直至 Hk 不发生冲突为止，则 Hk 为该记录在表中的散列地址。

这种方法在寻找 ”下一个” 空的散列地址时，原来的数组空间对所有的元素都是开放的所以称为开放地址法。通常把寻找 “下一个” 空位的过程称为探测，上述方法可用如下公式表示：
$$
H{i}=(H(key)+d(i))\%m, i=1,2,…,k(k≤m-l)
$$
其中，H(key)为散列函数，m 为散列表表长，d为增量序列。根据d取值的不同，可以分为以下3种探测方法。

![image-20240622021901623](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622021901623.png)

### 2.链地址法：针对每一个同义词建立一个链表





# ![image-20240622022051230](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022051230.png)



# 三.查找

![image-20240622022121724](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022121724.png)

![image-20240622022133499](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022133499.png)

![image-20240622022259205](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022259205.png)

# 四.循环队列

![image-20240622022201386](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022201386.png)

![image-20240622022210235](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022210235.png)

![image-20240622022218497](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022218497.png)

# 五.树

![image-20240622022335576](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022335576.png)

**树可以等价转化二叉树，树的先序遍历序列与其相应的二叉树的前序遍历序列相同**

**高度=层数-1，无向图节点度数=相连边数**

**度的定义：节点所拥有的子树的数目称为该节点的度******（注意： 叶子节点的度为0）******

![image-20240622022448754](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022448754.png)

![image-20240622022457710](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022457710.png)

![image-20240622022507037](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022507037.png)

# 六.图

![image-20240622022538821](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022538821.png)

![image-20240622022550898](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022550898.png)

**如果各边权值各不相同，存在唯一最小生成树**。

**对任意一个连通的无向图，如果存在一个环，且这个环中的一条边的权值大于该环中任意一个其它的边的权值，那么这条边一定不会是该无向图的最小生成树中的边。**



![image-20240622022631738](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20240622022631738.png)



**有 n（n>=2）个顶点的有向强连通图最少有 _ _ _ _ _ 条边。n**

**拓扑排序只适用于DAG有向无环图**。

**一个二叉树是二叉搜索树，当且仅当其中序遍历是递增序列。** 

**prim适合稠密图，kruskal适合稀疏图**。

**dijkstra不能有负权边**。

 

 

